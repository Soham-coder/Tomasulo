001000 00000 00001 00000000 00001010 add r1, r0, 10
001000 00001 00001 00000000 00001010 add r1, r1, 10
111111 00000 00000 00000000 00000000 halt


// detect bug in testcase6 when the target of readreg and the target of writereg is the same

> 寄存器状态表存放最新的寄存器来源
> 因此第二条指令流入的时候，会把r1的来源设置为第二个保留站
> 问题在于，第二条指令操作数r1未就绪，但对应的保留站号并不对
> 说明，在流入的时候， 更新寄存器状态表， 与 确定操作数的来源（译码）的先后顺序暂时不明了

以上都是我瞎逼逼
其实只是一开始指令代码写错了
这个通过